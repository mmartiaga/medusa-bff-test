name: Deploy to Render

on:
  push:
    branches: [main]

permissions:
  contents: read
  deployments: write
  packages: write

jobs:
  detect-changes:
    name: Detect changes
    runs-on: ubuntu-latest
    outputs:
      gateway: ${{ steps.changes.outputs.gateway }}
      products: ${{ steps.changes.outputs.products }}
      orders: ${{ steps.changes.outputs.orders }}
      content: ${{ steps.changes.outputs.content }}
      customers: ${{ steps.changes.outputs.customers }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - id: changes
        uses: dorny/paths-filter@v3
        with:
          base: ${{ github.event.before || 'HEAD^' }}
          filters: |
            gateway:
              - 'apps/gateway/**'
              - 'packages/**'
              - 'turbo.json'
              - 'pnpm-lock.yaml'
              - 'render.yaml'
            products:
              - 'apps/subgraphs/products/**'
              - 'packages/**'
              - 'turbo.json'
              - 'pnpm-lock.yaml'
              - 'render.yaml'
            orders:
              - 'apps/subgraphs/orders/**'
              - 'packages/**'
              - 'turbo.json'
              - 'pnpm-lock.yaml'
              - 'render.yaml'
            content:
              - 'apps/subgraphs/content/**'
              - 'packages/**'
              - 'turbo.json'
              - 'pnpm-lock.yaml'
              - 'render.yaml'
            customers:
              - 'apps/subgraphs/customers/**'
              - 'packages/**'
              - 'turbo.json'
              - 'pnpm-lock.yaml'
              - 'render.yaml'

  build-gateway:
    needs: detect-changes
    if: needs.detect-changes.outputs.gateway == 'true'
    uses: ./.github/workflows/_build-docker.yaml
    with:
      app: gateway
      dockerfile: ./apps/gateway/Dockerfile

  build-products:
    needs: detect-changes
    if: needs.detect-changes.outputs.products == 'true'
    uses: ./.github/workflows/_build-docker.yaml
    with:
      app: products
      dockerfile: ./apps/subgraphs/products/Dockerfile

  build-orders:
    needs: detect-changes
    if: needs.detect-changes.outputs.orders == 'true'
    uses: ./.github/workflows/_build-docker.yaml
    with:
      app: orders
      dockerfile: ./apps/subgraphs/orders/Dockerfile

  build-content:
    needs: detect-changes
    if: needs.detect-changes.outputs.content == 'true'
    uses: ./.github/workflows/_build-docker.yaml
    with:
      app: content
      dockerfile: ./apps/subgraphs/content/Dockerfile

  build-customers:
    needs: detect-changes
    if: needs.detect-changes.outputs.customers == 'true'
    uses: ./.github/workflows/_build-docker.yaml
    with:
      app: customers
      dockerfile: ./apps/subgraphs/customers/Dockerfile

  smoke-products:
    needs: [detect-changes, build-products]
    if: needs.detect-changes.outputs.products == 'true'
    uses: ./.github/workflows/_deploy-render.yaml
    with:
      app: products-smoke
      image: ${{ needs.build-products.outputs.image_tag }}
    secrets:
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY}}

  publish-subgraph-smoke-products:
    needs: [detect-changes, smoke-products]
    if: needs.detect-changes.outputs.products == 'true' && needs.smoke-products.result == 'success'
    uses: ./.github/workflows/_publish-subgraph.yaml
    with:
      environment: smoke
      subgraph_name: products
    secrets:
      REGISTRY_REPO: ${{ secrets.SCHEMA_REGISTRY_REPO }}
      REGISTRY_TOKEN: ${{ secrets.SCHEMA_REGISTRY_TOKEN }}
      SUBGRAPH_URL: ${{ secrets.PRODUCTS_URL }}

  smoke-orders:
    needs: [detect-changes, build-orders]
    if: needs.detect-changes.outputs.orders == 'true'
    uses: ./.github/workflows/_deploy-render.yaml
    with:
      app: orders-smoke
      image: ${{ needs.build-orders.outputs.image_tag }}
    secrets:
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY}}

  publish-subgraph-smoke-orders:
    needs: [detect-changes, smoke-orders]
    if: needs.detect-changes.outputs.orders == 'true' && needs.smoke-orders.result == 'success'
    uses: ./.github/workflows/_publish-subgraph.yaml
    with:
      environment: smoke
      subgraph_name: orders
    secrets:
      REGISTRY_REPO: ${{ secrets.SCHEMA_REGISTRY_REPO }}
      REGISTRY_TOKEN: ${{ secrets.SCHEMA_REGISTRY_TOKEN }}
      SUBGRAPH_URL: ${{ secrets.ORDERS_URL }}

  smoke-content:
    needs: [detect-changes, build-content]
    if: needs.detect-changes.outputs.content == 'true'
    uses: ./.github/workflows/_deploy-render.yaml
    with:
      app: content-smoke
      image: ${{ needs.build-content.outputs.image_tag }}
    secrets:
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY}}

  publish-subgraph-smoke-content:
    needs: [detect-changes, smoke-content]
    if: needs.detect-changes.outputs.content == 'true' && needs.smoke-content.result == 'success'
    uses: ./.github/workflows/_publish-subgraph.yaml
    with:
      environment: smoke
      subgraph_name: content
    secrets:
      REGISTRY_REPO: ${{ secrets.SCHEMA_REGISTRY_REPO }}
      REGISTRY_TOKEN: ${{ secrets.SCHEMA_REGISTRY_TOKEN }}
      SUBGRAPH_URL: ${{ secrets.CONTENT_URL }}

  smoke-customers:
    needs: [detect-changes, build-customers]
    if: needs.detect-changes.outputs.customers == 'true'
    uses: ./.github/workflows/_deploy-render.yaml
    with:
      app: customers-smoke
      image: ${{ needs.build-customers.outputs.image_tag }}
    secrets:
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY}}

  publish-subgraph-smoke-customers:
    needs: [detect-changes, smoke-customers]
    if: needs.detect-changes.outputs.customers == 'true' && needs.smoke-customers.result == 'success'
    uses: ./.github/workflows/_publish-subgraph.yaml
    with:
      environment: smoke
      subgraph_name: customers
    secrets:
      REGISTRY_REPO: ${{ secrets.SCHEMA_REGISTRY_REPO }}
      REGISTRY_TOKEN: ${{ secrets.SCHEMA_REGISTRY_TOKEN }}
      SUBGRAPH_URL: ${{ secrets.CUSTOMERS_URL }}

  publish-supergraph-smoke:
    needs:
      [
        detect-changes,
        publish-subgraph-smoke-products,
        publish-subgraph-smoke-content,
        publish-subgraph-smoke-orders,
        publish-subgraph-smoke-customers,
      ]
    if: |
      always() &&
      (needs.detect-changes.outputs.products == 'true' ||
       needs.detect-changes.outputs.content == 'true' ||
       needs.detect-changes.outputs.orders == 'true' ||
       needs.detect-changes.outputs.customers == 'true') &&
      (needs.detect-changes.outputs.products != 'true' || needs.publish-subgraph-smoke-products.result == 'success') &&
      (needs.detect-changes.outputs.content != 'true' || needs.publish-subgraph-smoke-content.result == 'success') &&
      (needs.detect-changes.outputs.orders != 'true' || needs.publish-subgraph-smoke-orders.result == 'success') &&
      (needs.detect-changes.outputs.customers != 'true' || needs.publish-subgraph-smoke-customers.result == 'success')
    uses: ./.github/workflows/_publish-supergraph.yaml
    with:
      environment: smoke
    secrets:
      REGISTRY_REPO: ${{ secrets.SCHEMA_REGISTRY_REPO }}
      REGISTRY_TOKEN: ${{ secrets.SCHEMA_REGISTRY_TOKEN }}
      PRODUCTS_URL: ${{ secrets.PRODUCTS_URL }}
      CUSTOMERS_URL: ${{ secrets.CUSTOMERS_URL }}
      CONTENT_URL: ${{ secrets.CONTENT_URL }}
      ORDERS_URL: ${{ secrets.ORDERS_URL }}
      SUPERGRAPH_RELOAD_URL: ${{ secrets.SUPERGRAPH_RELOAD_URL }}
      SUPERGRAPH_RELOAD_TOKEN: ${{ secrets.SUPERGRAPH_RELOAD_TOKEN }}

  smoke-gateway:
    needs:
      [
        detect-changes,
        build-gateway,
        smoke-products,
        smoke-content,
        smoke-orders,
        smoke-customers,
      ]
    if: needs.detect-changes.outputs.gateway == 'true'
    uses: ./.github/workflows/_deploy-render.yaml
    with:
      app: gateway-smoke
      image: ${{ needs.build-gateway.outputs.image_tag }}
    secrets:
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY}}

  prod-products:
    needs: [detect-changes, build-products]
    if: needs.detect-changes.outputs.products == 'true'
    uses: ./.github/workflows/_deploy-render.yaml
    with:
      app: products-prod
      image: ${{ needs.build-products.outputs.image_tag }}
    secrets:
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY}}

  publish-subgraph-prod-products:
    needs: [detect-changes, prod-products]
    if: needs.detect-changes.outputs.products == 'true' && needs.prod-products.result == 'success'
    uses: ./.github/workflows/_publish-subgraph.yaml
    with:
      environment: prod
      subgraph_name: products
    secrets:
      REGISTRY_REPO: ${{ secrets.SCHEMA_REGISTRY_REPO }}
      REGISTRY_TOKEN: ${{ secrets.SCHEMA_REGISTRY_TOKEN }}
      SUBGRAPH_URL: ${{ secrets.PRODUCTS_URL }}

  prod-orders:
    needs: [detect-changes, build-orders]
    if: needs.detect-changes.outputs.orders == 'true'
    uses: ./.github/workflows/_deploy-render.yaml
    with:
      app: orders-prod
      image: ${{ needs.build-orders.outputs.image_tag }}
    secrets:
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY}}

  publish-subgraph-prod-orders:
    needs: [detect-changes, prod-orders]
    if: needs.detect-changes.outputs.orders == 'true' && needs.prod-orders.result == 'success'
    uses: ./.github/workflows/_publish-subgraph.yaml
    with:
      environment: prod
      subgraph_name: orders
    secrets:
      REGISTRY_REPO: ${{ secrets.SCHEMA_REGISTRY_REPO }}
      REGISTRY_TOKEN: ${{ secrets.SCHEMA_REGISTRY_TOKEN }}
      SUBGRAPH_URL: ${{ secrets.ORDERS_URL }}

  prod-content:
    needs: [detect-changes, build-content]
    if: needs.detect-changes.outputs.content == 'true'
    uses: ./.github/workflows/_deploy-render.yaml
    with:
      app: content-prod
      image: ${{ needs.build-content.outputs.image_tag }}
    secrets:
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY}}

  publish-subgraph-prod-content:
    needs: [detect-changes, prod-content]
    if: needs.detect-changes.outputs.content == 'true' && needs.prod-content.result == 'success'
    uses: ./.github/workflows/_publish-subgraph.yaml
    with:
      environment: prod
      subgraph_name: content
    secrets:
      REGISTRY_REPO: ${{ secrets.SCHEMA_REGISTRY_REPO }}
      REGISTRY_TOKEN: ${{ secrets.SCHEMA_REGISTRY_TOKEN }}
      SUBGRAPH_URL: ${{ secrets.CONTENT_URL }}

  prod-customers:
    needs: [detect-changes, build-customers]
    if: needs.detect-changes.outputs.customers == 'true'
    uses: ./.github/workflows/_deploy-render.yaml
    with:
      app: customers-prod
      image: ${{ needs.build-customers.outputs.image_tag }}
    secrets:
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY}}

  publish-subgraph-prod-customers:
    needs: [detect-changes, prod-customers]
    if: needs.detect-changes.outputs.customers == 'true' && needs.prod-customers.result == 'success'
    uses: ./.github/workflows/_publish-subgraph.yaml
    with:
      environment: prod
      subgraph_name: customers
    secrets:
      REGISTRY_REPO: ${{ secrets.SCHEMA_REGISTRY_REPO }}
      REGISTRY_TOKEN: ${{ secrets.SCHEMA_REGISTRY_TOKEN }}
      SUBGRAPH_URL: ${{ secrets.CUSTOMERS_URL }}

  publish-supergraph-prod:
    needs:
      [
        detect-changes,
        publish-subgraph-prod-products,
        publish-subgraph-prod-content,
        publish-subgraph-prod-orders,
        publish-subgraph-prod-customers,
      ]
    if: |
      always() &&
      (needs.detect-changes.outputs.products == 'true' ||
       needs.detect-changes.outputs.content == 'true' ||
       needs.detect-changes.outputs.orders == 'true' ||
       needs.detect-changes.outputs.customers == 'true') &&
      (needs.detect-changes.outputs.products != 'true' || needs.publish-subgraph-prod-products.result == 'success') &&
      (needs.detect-changes.outputs.content != 'true' || needs.publish-subgraph-prod-content.result == 'success') &&
      (needs.detect-changes.outputs.orders != 'true' || needs.publish-subgraph-prod-orders.result == 'success') &&
      (needs.detect-changes.outputs.customers != 'true' || needs.publish-subgraph-prod-customers.result == 'success')
    uses: ./.github/workflows/_publish-supergraph.yaml
    with:
      environment: prod
    secrets:
      REGISTRY_REPO: ${{ secrets.SCHEMA_REGISTRY_REPO }}
      REGISTRY_TOKEN: ${{ secrets.SCHEMA_REGISTRY_TOKEN }}
      PRODUCTS_URL: ${{ secrets.PRODUCTS_URL }}
      CUSTOMERS_URL: ${{ secrets.CUSTOMERS_URL }}
      CONTENT_URL: ${{ secrets.CONTENT_URL }}
      ORDERS_URL: ${{ secrets.ORDERS_URL }}
      SUPERGRAPH_RELOAD_URL: ${{ secrets.SUPERGRAPH_RELOAD_URL }}
      SUPERGRAPH_RELOAD_TOKEN: ${{ secrets.SUPERGRAPH_RELOAD_TOKEN }}

  prod-gateway:
    needs: [detect-changes, build-gateway, prod-products, prod-content, prod-customers, prod-orders]
    if: needs.detect-changes.outputs.gateway == 'true'
    uses: ./.github/workflows/_deploy-render.yaml
    with:
      app: gateway-prod
      image: ${{ needs.build-gateway.outputs.image_tag }}
    secrets:
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY}}

  create-tags:
    name: Create production tags
    needs:
      [
        detect-changes,
        build-products,
        build-orders,
        build-content,
        build-customers,
        build-gateway,
        prod-products,
        prod-orders,
        prod-content,
        prod-customers,
        prod-gateway,
      ]
    if: |
      always() &&
      (needs.prod-products.result == 'success' ||
       needs.prod-orders.result == 'success' ||
       needs.prod-content.result == 'success' ||
       needs.prod-customers.result == 'success' ||
       needs.prod-gateway.result == 'success')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Read service versions
        id: versions
        run: |
          PRODUCTS_VERSION=$(jq -r '.version' apps/subgraphs/products/package.json)
          ORDERS_VERSION=$(jq -r '.version' apps/subgraphs/orders/package.json)
          CONTENT_VERSION=$(jq -r '.version' apps/subgraphs/content/package.json)
          CUSTOMERS_VERSION=$(jq -r '.version' apps/subgraphs/customers/package.json)
          GATEWAY_VERSION=$(jq -r '.version' apps/gateway/package.json)

          for SERVICE in "products" "orders" "content" "customers" "gateway"; do
            SERVICE_UPPER=$(echo "$SERVICE" | tr '[:lower:]' '[:upper:]')
            VERSION_VAR="${SERVICE_UPPER}_VERSION"
            VERSION="${!VERSION_VAR}"

            if [ -z "$VERSION" ] || [ "$VERSION" = "null" ]; then
              echo "::error::Invalid version in $SERVICE package.json: '$VERSION'"
              exit 1
            fi

            if ! echo "$VERSION" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+'; then
              echo "::error::Version '$VERSION' for $SERVICE is not valid semver (must be X.Y.Z)"
              exit 1
            fi
          done

          {
            echo "products=$PRODUCTS_VERSION"
            echo "orders=$ORDERS_VERSION"
            echo "content=$CONTENT_VERSION"
            echo "customers=$CUSTOMERS_VERSION"
            echo "gateway=$GATEWAY_VERSION"
          } >> "$GITHUB_OUTPUT"

      - name: Create git tags for deployed services
        env:
          PRODUCTS_RESULT: ${{ needs.prod-products.result }}
          PRODUCTS_VERSION: ${{ steps.versions.outputs.products }}
          ORDERS_RESULT: ${{ needs.prod-orders.result }}
          ORDERS_VERSION: ${{ steps.versions.outputs.orders }}
          CONTENT_RESULT: ${{ needs.prod-content.result }}
          CONTENT_VERSION: ${{ steps.versions.outputs.content }}
          CUSTOMERS_RESULT: ${{ needs.prod-customers.result }}
          CUSTOMERS_VERSION: ${{ steps.versions.outputs.customers }}
          GATEWAY_RESULT: ${{ needs.prod-gateway.result }}
          GATEWAY_VERSION: ${{ steps.versions.outputs.gateway }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          SERVICES=("products" "orders" "content" "customers" "gateway")

          for SERVICE in "${SERVICES[@]}"; do
            SERVICE_UPPER=$(echo "$SERVICE" | tr '[:lower:]' '[:upper:]')
            RESULT_VAR="${SERVICE_UPPER}_RESULT"
            VERSION_VAR="${SERVICE_UPPER}_VERSION"

            RESULT="${!RESULT_VAR}"
            VERSION="${!VERSION_VAR}"

            if [ "$RESULT" = "success" ] && [ -n "$VERSION" ]; then
              TAG="@gfed-medusa-bff/${SERVICE}@${VERSION}"

              if ! git rev-parse "$TAG" >/dev/null 2>&1; then
                git tag -a "$TAG" -m "Production release $TAG"

                if git push origin "$TAG"; then
                  echo "✓ Created tag: $TAG"
                else
                  echo "::error::Failed to push tag: $TAG"
                  exit 1
                fi
              else
                TAG_COMMIT=$(git rev-list -n 1 "$TAG" 2>/dev/null)
                CURRENT_COMMIT=$(git rev-parse HEAD)

                if [ "$TAG_COMMIT" = "$CURRENT_COMMIT" ]; then
                  echo "⚠ Tag $TAG already exists for this commit (idempotent deployment)"
                else
                  echo "::error::Tag $TAG already exists but points to different commit"
                  echo "::error::Current commit: $CURRENT_COMMIT"
                  echo "::error::Tag points to:  $TAG_COMMIT"
                  echo "::error::Please bump the version in ${SERVICE} package.json before deploying"
                  exit 1
                fi
              fi
            fi
          done
